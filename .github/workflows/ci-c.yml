name: "CI Quality (C/C++/Python/Java) - run ONLY matching OS (Linux/macOS vs Windows)"

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # ==========================================================
  # 1) Detect "origin OS" (heuristic)
  #    - if CRLF found in tracked source files => windows
  #    - else => unix (linux/macos)
  # ==========================================================
  detect-origin:
    name: "Detect origin (windows vs unix)"
    runs-on: ubuntu-24.04
    outputs:
      origin: ${{ steps.detector.outputs.origin }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect origin by CRLF in tracked sources
        id: detector
        shell: bash
        run: |
          set -euo pipefail

          FILES="$(git ls-files \
            '*.c' '*.h' '*.cpp' '*.hpp' '*.hxx' '*.cc' '*.cxx' \
            '*.py' '*.java' '*.yml' '*.yaml' '*.sh' '*.md' || true)"

          if [ -z "${FILES}" ]; then
            echo "origin=unix" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if printf "%s\n" "$FILES" | xargs -r grep -Il $'\r' -- >/dev/null 2>&1; then
            echo "origin=windows" >> "$GITHUB_OUTPUT"
          else
            echo "origin=unix" >> "$GITHUB_OUTPUT"
          fi

      - name: Show detected origin
        run: echo "Detected origin = ${{ steps.detector.outputs.origin }}"

  # =========================
  # C (format + static + compile) ONLY on matching OS
  # =========================
  quality-c:
    name: "C Quality on ${{ matrix.os }}"
    needs: [detect-origin]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-14, windows-2022]
    if: |
      (needs.detect-origin.outputs.origin == 'windows' && matrix.os == 'windows-2022') ||
      (needs.detect-origin.outputs.origin == 'unix'    && (matrix.os == 'ubuntu-24.04' || matrix.os == 'macos-14'))

    steps:
      - uses: actions/checkout@v4

      - name: Detect C files
        id: ccheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.c" ! -path "./.git/*" | grep -q .; then
            echo "has_c=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_c=false" >> "$GITHUB_OUTPUT"
          fi

      # Install tools
      - name: Install C tools (Linux)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang-format clang-tidy cppcheck

      - name: Install C tools (macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C tools (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      # FORCE FORMAT (clang-format -style=LLVM -i)
      - name: Force LLVM format (C) (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*" -print0 \
            | xargs -0 -I{} clang-format -style=LLVM -i "{}"

      - name: Force LLVM format (C) (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Get-ChildItem -Recurse -File -Include *.c,*.h |
            Where-Object { $_.FullName -notmatch "\\.git\\" } |
            ForEach-Object { & clang-format -style=LLVM -i $_.FullName }

      # CHECK STYLE
      - name: Check LLVM style (C) (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          while IFS= read -r f; do
            clang-format -style=LLVM "$f" | diff -u "$f" - >/dev/null || {
              echo "::error file=$f::clang-format LLVM mismatch"
              exit 1
            }
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*")

      - name: Check LLVM style (C) (Windows - robust)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          function Normalize-File([string]$path) {
            $bytes = [System.IO.File]::ReadAllBytes($path)
            if ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
              $bytes = $bytes[3..($bytes.Length-1)]
            }
            $text = [System.Text.Encoding]::UTF8.GetString($bytes)
            $text = $text -replace "`r`n", "`n"
            $text = $text -replace "`r", "`n"
            if ($text.Length -gt 0 -and -not $text.EndsWith("`n")) { $text += "`n" }
            [System.IO.File]::WriteAllText($path, $text, (New-Object System.Text.UTF8Encoding($false)))
          }

          $files = Get-ChildItem -Recurse -File -Include *.c,*.h | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No C files -> skipping"; exit 0 }

          foreach ($f in $files) {
            $tmp = Join-Path $env:RUNNER_TEMP ("cf_" + [System.Guid]::NewGuid().ToString() + ".tmp")
            $formatted = & clang-format -style=LLVM $f.FullName
            [System.IO.File]::WriteAllText($tmp, $formatted, (New-Object System.Text.UTF8Encoding($false)))

            Normalize-File $f.FullName
            Normalize-File $tmp

            $a = [System.IO.File]::ReadAllBytes($f.FullName)
            $b = [System.IO.File]::ReadAllBytes($tmp)

            if ($a.Length -ne $b.Length) { throw "clang-format mismatch: $($f.FullName)" }
            for ($i=0; $i -lt $a.Length; $i++) { if ($a[$i] -ne $b[$i]) { throw "clang-format mismatch: $($f.FullName)" } }

            Remove-Item -Force $tmp
          }

      # STATIC
      - name: Static analysis (cppcheck) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      # COMPILE
      - name: Compile all C units (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_c/obj
          while IFS= read -r f; do
            out="build_c/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            clang -std=c11 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
          done < <(find . -type f -name "*.c" ! -path "./.git/*")

      - name: Compile all C units (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference="Stop"
          New-Item -ItemType Directory -Force -Path build_c/obj | Out-Null
          $files = Get-ChildItem -Recurse -File -Filter *.c | Where-Object { $_.FullName -notmatch "\\.git\\" }
          foreach ($f in $files) {
            $safe = ($f.FullName -replace '^[A-Za-z]:\\', '' -replace '[\\/]', '_')
            & clang -std=c11 -Wall -Wextra -Werror -O2 -c $f.FullName -o "build_c/obj/$safe.obj"
          }

      - name: C skipped (no .c)
        if: steps.ccheck.outputs.has_c != 'true'
        run: echo "No .c files found -> skipping C job"

  # =========================
  # C++ (format + static + compile) ONLY on matching OS
  # =========================
  quality-cpp:
    name: "C++ Quality on ${{ matrix.os }}"
    needs: [detect-origin]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-14, windows-2022]
    if: |
      (needs.detect-origin.outputs.origin == 'windows' && matrix.os == 'windows-2022') ||
      (needs.detect-origin.outputs.origin == 'unix'    && (matrix.os == 'ubuntu-24.04' || matrix.os == 'macos-14'))

    steps:
      - uses: actions/checkout@v4

      - name: Detect C++ files
        id: cppcheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" -o -name "*.hpp" -o -name "*.hxx" \) ! -path "./.git/*" | grep -q .; then
            echo "has_cpp=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_cpp=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install C++ tools (Linux)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang++ clang-format clang-tidy cppcheck

      - name: Install C++ tools (macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C++ tools (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Force LLVM format (C++) (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.h" \) ! -path "./.git/*" -print0 \
            | xargs -0 -I{} clang-format -style=LLVM -i "{}"

      - name: Force LLVM format (C++) (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx,*.hpp,*.hxx,*.h |
            Where-Object { $_.FullName -notmatch "\\.git\\" } |
            ForEach-Object { & clang-format -style=LLVM -i $_.FullName }

      - name: Static analysis (cppcheck) [C++]
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: Compile all C++ units (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_cpp/obj
          while IFS= read -r f; do
            out="build_cpp/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            clang++ -std=c++17 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
          done < <(find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*")

      - name: Compile all C++ units (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference="Stop"
          New-Item -ItemType Directory -Force -Path build_cpp/obj | Out-Null
          $files = Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx | Where-Object { $_.FullName -notmatch "\\.git\\" }
          foreach ($f in $files) {
            $safe = ($f.FullName -replace '^[A-Za-z]:\\', '' -replace '[\\/]', '_')
            & clang++ -std=c++17 -Wall -Wextra -Werror -O2 -c $f.FullName -o "build_cpp/obj/$safe.obj"
          }

      - name: C++ skipped (no sources)
        if: steps.cppcheck.outputs.has_cpp != 'true'
        run: echo "No C++ files found -> skipping C++ job"

  # =========================
  # PYTHON (format + lint + type + tests) ONLY on matching OS
  # =========================
  quality-python:
    name: "Python Quality on ${{ matrix.os }}"
    needs: [detect-origin]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-14, windows-2022]
    if: |
      (needs.detect-origin.outputs.origin == 'windows' && matrix.os == 'windows-2022') ||
      (needs.detect-origin.outputs.origin == 'unix'    && (matrix.os == 'ubuntu-24.04' || matrix.os == 'macos-14'))

    steps:
      - uses: actions/checkout@v4

      - name: Detect Python files
        id: pycheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.py" ! -path "./.git/*" | grep -q .; then
            echo "has_py=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_py=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-python@v5
        if: steps.pycheck.outputs.has_py == 'true'
        with:
          python-version: "3.11"

      - name: Install tools
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install ruff mypy pytest

      - name: Format check (ruff)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff format --check .

      - name: Lint (ruff)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff check .

      - name: Type-check (mypy) best-effort
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m mypy . || true

      - name: Syntax check (compileall)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m compileall -q .

      - name: Tests (pytest if present)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ -d "tests" ] || find . -maxdepth 3 -type f -name "test_*.py" | grep -q .; then
            python -m pytest -q
          else
            echo "No tests detected -> skipping"
          fi

      - name: Python skipped (no .py)
        if: steps.pycheck.outputs.has_py != 'true'
        run: echo "No .py files found -> skipping Python job"

  # =========================
  # JAVA (compile + optional tests) ONLY on matching OS
  # =========================
  quality-java:
    name: "Java Quality on ${{ matrix.os }}"
    needs: [detect-origin]
    runs-on: ${{ matrix.os }}
    timeout-minutes: 15
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, macos-14, windows-2022]
    if: |
      (needs.detect-origin.outputs.origin == 'windows' && matrix.os == 'windows-2022') ||
      (needs.detect-origin.outputs.origin == 'unix'    && (matrix.os == 'ubuntu-24.04' || matrix.os == 'macos-14'))

    steps:
      - uses: actions/checkout@v4

      - name: Detect Java files
        id: javacheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.java" ! -path "./.git/*" | grep -q .; then
            echo "has_java=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_java=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-java@v4
        if: steps.javacheck.outputs.has_java == 'true'
        with:
          distribution: temurin
          java-version: "17"

      - name: Compile all Java files
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          mapfile -t JAVA_FILES < <(find . -type f -name "*.java" ! -path "./.git/*")
          javac -d out "${JAVA_FILES[@]}"

      - name: Run tests if Maven/Gradle
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "pom.xml" ]; then
            echo "pom.xml found -> mvn test"
            if [ "${RUNNER_OS}" = "Windows" ]; then
              choco install -y maven
            elif [ "${RUNNER_OS}" = "macOS" ]; then
              brew install maven
            else
              sudo apt-get update && sudo apt-get install -y maven
            fi
            mvn -q test
            exit 0
          fi

          if [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            echo "gradle build found -> gradle test"
            if [ "${RUNNER_OS}" = "Windows" ]; then
              choco install -y gradle
            elif [ "${RUNNER_OS}" = "macOS" ]; then
              brew install gradle
            else
              sudo apt-get update && sudo apt-get install -y gradle
            fi
            gradle test
            exit 0
          fi

          echo "No Maven/Gradle build detected -> skipping tests"

      - name: Java skipped (no .java)
        if: steps.javacheck.outputs.has_java != 'true'
        run: echo "No .java files found -> skipping Java job"
