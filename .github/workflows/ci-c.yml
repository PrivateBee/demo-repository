name: "CI Quality (LLVM style + Static/Dynamic) - C/C++/Python/Java (Linux/Windows/macOS)"

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # ==========================================================
  # COMMON: CRLF guard (runs on Linux; detects Windows CRLF)
  # ==========================================================
  guard-crlf:
    name: "Guard (no CRLF in sources)"
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - name: Fail if CRLF detected in source files
        shell: bash
        run: |
          set -euo pipefail
          if git grep -Il $'\r' -- \
            '*.c' '*.h' '*.cpp' '*.hpp' '*.hxx' '*.cc' '*.cxx' \
            '*.py' '*.java' '*.sh' '*.yml' '*.yaml' '*.md' ; then
            echo "::error::CRLF detected in files above. Fix by converting to LF and/or using .gitattributes."
            exit 1
          fi
          echo "OK: no CRLF found in targeted files."

  # =========================
  # C (auto-format LLVM + static + compile) on all OS
  # =========================
  quality-c:
    name: "C (LLVM auto-format + static + compile) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect C files
        id: ccheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.c" ! -path "./.git/*" | grep -q .; then
            echo "has_c=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_c=false" >> "$GITHUB_OUTPUT"
          fi

      # -------- Install tools per OS --------
      - name: Install C tools (Linux)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang-format clang-tidy cppcheck

      - name: Install C tools (macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C tools (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      # -------------------------
      # 0) AUTO-FORMAT LLVM
      # -------------------------
      - name: Auto-format LLVM (clang-format) [C] (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          while IFS= read -r f; do
            clang-format -style=LLVM -i "$f"
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*")

      - name: Auto-format LLVM (clang-format) [C] (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $files = Get-ChildItem -Recurse -File -Include *.c,*.h | Where-Object { $_.FullName -notmatch "\\.git\\" }
          foreach ($f in $files) {
            & clang-format -style=LLVM -i $f.FullName
          }

      # -------------------------
      # 1) CHECK LLVM STYLE (Windows: normalize LF + remove BOM)
      # -------------------------
      - name: Check LLVM style (clang-format) [C] (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          found=0
          while IFS= read -r f; do
            found=1
            clang-format -style=LLVM "$f" | diff -u "$f" - >/dev/null || {
              echo "::error file=$f::clang-format LLVM mismatch (unexpected after auto-format)"
              exit 1
            }
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No C files -> skipping format check"
          fi

      - name: Check LLVM style (clang-format) [C] (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          function Normalize-Text([string]$s) {
            if ($null -eq $s) { return "" }
            if ($s.Length -gt 0 -and [int]$s[0] -eq 0xFEFF) { $s = $s.Substring(1) } # BOM
            $s = $s -replace "`r`n", "`n"
            $s = $s -replace "`r", "`n"
            return $s
          }

          $files = Get-ChildItem -Recurse -File -Include *.c,*.h | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No C files -> skipping"; exit 0 }

          foreach ($f in $files) {
            $formatted = & clang-format -style=LLVM $f.FullName
            $current = [System.IO.File]::ReadAllText($f.FullName)

            $formattedN = Normalize-Text $formatted
            $currentN   = Normalize-Text $current

            if ($formattedN -ne $currentN) {
              Write-Error "clang-format LLVM mismatch: $($f.FullName). Fix with: clang-format -style=LLVM -i `"$($f.FullName)`""
              exit 1
            }
          }

      # -------------------------
      # 2) STATIC ANALYSIS
      # -------------------------
      - name: Static analysis (cppcheck) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: Static analysis (clang-tidy if compile_commands.json exists) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f compile_commands.json ]; then
            echo "No compile_commands.json -> skipping clang-tidy"
            exit 0
          fi
          found=0
          while IFS= read -r f; do
            found=1
            clang-tidy -p . -checks="-*,clang-analyzer-*" "$f"
          done < <(find . -type f -name "*.c" ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No .c files -> skipping clang-tidy"
          fi

      # -------------------------
      # 3) BUILD (compile everything, no linking)
      # -------------------------
      - name: Compile all C translation units (no linking) (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_c/obj
          found=0
          while IFS= read -r f; do
            found=1
            out="build_c/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            echo "CC  $f"
            if command -v clang >/dev/null 2>&1; then
              clang -std=c11 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
            else
              gcc -std=c11 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
            fi
          done < <(find . -type f -name "*.c" ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No .c files -> skipping compile"
          fi

      - name: Compile all C translation units (no linking) (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          New-Item -ItemType Directory -Force -Path build_c/obj | Out-Null
          $files = Get-ChildItem -Recurse -File -Filter *.c | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No .c files -> skipping compile"; exit 0 }
          foreach ($f in $files) {
            $safe = ($f.FullName -replace '^[A-Za-z]:\\', '' -replace '[\\/]', '_')
            $out = "build_c/obj/$safe.obj"
            Write-Host "CC  $($f.FullName)"
            & clang -std=c11 -Wall -Wextra -Werror -O2 -c $f.FullName -o $out
          }

      - name: C skipped (no .c)
        if: steps.ccheck.outputs.has_c != 'true'
        run: echo "No .c files found -> skipping C job"

  # =========================
  # C DYNAMIC (Linux only)
  # =========================
  quality-c-dynamic:
    name: "C (dynamic: ASan/UBSan + Valgrind) on Linux"
    runs-on: ubuntu-24.04
    timeout-minutes: 12
    needs: [guard-crlf]
    steps:
      - uses: actions/checkout@v4

      - name: Detect C files
        id: ccheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.c" ! -path "./.git/*" | grep -q .; then
            echo "has_c=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_c=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install C tools (Linux)
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang valgrind

      - name: Link & run with sanitizers + valgrind (only if exactly one main) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          MAIN_FILES="$(grep -Rsn --include="*.c" -E '^\s*int\s+main\s*\(' . | cut -d: -f1 | sort -u || true)"
          if [ -z "$MAIN_FILES" ]; then
            echo "No main() found -> skipping dynamic analysis"
            exit 0
          fi
          if [ "$(echo "$MAIN_FILES" | wc -l | tr -d ' ')" -ne 1 ]; then
            echo "Multiple main() found -> skipping link/run"
            echo "$MAIN_FILES"
            exit 0
          fi

          mkdir -p build_c
          C_FILES="$(find . -type f -name "*.c" ! -path "./.git/*")"

          echo "Build + run (sanitizers):"
          clang -std=c11 -Wall -Wextra -Werror -O1 -g \
            -fsanitize=address,undefined -fno-omit-frame-pointer \
            $C_FILES -o build_c/app_asan
          ./build_c/app_asan

          echo "Build + run (valgrind on non-sanitized binary):"
          clang -std=c11 -Wall -Wextra -Werror -O1 -g \
            $C_FILES -o build_c/app_vg
          valgrind --error-exitcode=1 --leak-check=full ./build_c/app_vg

      - name: C dynamic skipped (no .c)
        if: steps.ccheck.outputs.has_c != 'true'
        run: echo "No .c files found -> skipping C dynamic job"

  # =========================
  # C++ (auto-format LLVM + static + compile) on all OS
  # =========================
  quality-cpp:
    name: "C++ (LLVM auto-format + static + compile) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect C++ files
        id: cppcheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f \( -name "*.cpp" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*" | grep -q .; then
            echo "has_cpp=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_cpp=false" >> "$GITHUB_OUTPUT"
          fi

      # -------- Install tools per OS --------
      - name: Install C++ tools (Linux)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang++ clang-format clang-tidy cppcheck

      - name: Install C++ tools (macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C++ tools (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      # -------------------------
      # 0) AUTO-FORMAT LLVM
      # -------------------------
      - name: Auto-format LLVM (clang-format) [C++] (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          while IFS= read -r f; do
            clang-format -style=LLVM -i "$f"
          done < <(
            find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.h" \) ! -path "./.git/*"
          )

      - name: Auto-format LLVM (clang-format) [C++] (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          $files = Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx,*.hpp,*.hxx,*.h | Where-Object { $_.FullName -notmatch "\\.git\\" }
          foreach ($f in $files) {
            & clang-format -style=LLVM -i $f.FullName
          }

      # -------------------------
      # 1) CHECK LLVM STYLE (Windows: normalize LF + remove BOM)
      # -------------------------
      - name: Check LLVM style (clang-format) [C++] (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          found=0
          while IFS= read -r f; do
            found=1
            clang-format -style=LLVM "$f" | diff -u "$f" - >/dev/null || {
              echo "::error file=$f::clang-format LLVM mismatch (unexpected after auto-format)"
              exit 1
            }
          done < <(
            find . -type f \( -name "*.cpp" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.cc" -o -name "*.cxx" -o -name "*.h" \) ! -path "./.git/*"
          )
          if [ "$found" -eq 0 ]; then
            echo "No C++ files -> skipping format check"
          fi

      - name: Check LLVM style (clang-format) [C++] (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          function Normalize-Text([string]$s) {
            if ($null -eq $s) { return "" }
            if ($s.Length -gt 0 -and [int]$s[0] -eq 0xFEFF) { $s = $s.Substring(1) } # BOM
            $s = $s -replace "`r`n", "`n"
            $s = $s -replace "`r", "`n"
            return $s
          }

          $files = Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx,*.hpp,*.hxx,*.h | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No C++ files -> skipping"; exit 0 }

          foreach ($f in $files) {
            $formatted = & clang-format -style=LLVM $f.FullName
            $current = [System.IO.File]::ReadAllText($f.FullName)

            $formattedN = Normalize-Text $formatted
            $currentN   = Normalize-Text $current

            if ($formattedN -ne $currentN) {
              Write-Error "clang-format LLVM mismatch: $($f.FullName). Fix with: clang-format -style=LLVM -i `"$($f.FullName)`""
              exit 1
            }
          }

      # -------------------------
      # 2) STATIC ANALYSIS
      # -------------------------
      - name: Static analysis (cppcheck) [C++]
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: Static analysis (clang-tidy if compile_commands.json exists) [C++]
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f compile_commands.json ]; then
            echo "No compile_commands.json -> skipping clang-tidy"
            exit 0
          fi
          found=0
          while IFS= read -r f; do
            found=1
            clang-tidy -p . -checks="-*,clang-analyzer-*,bugprone-*,performance-*,readability-*" "$f"
          done < <(find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No C++ sources -> skipping clang-tidy"
          fi

      # -------------------------
      # 3) BUILD (compile everything, no linking)
      # -------------------------
      - name: Compile all C++ translation units (no linking) (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_cpp/obj
          found=0
          while IFS= read -r f; do
            found=1
            out="build_cpp/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            echo "CXX $f"
            if command -v clang++ >/dev/null 2>&1; then
              clang++ -std=c++17 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
            else
              g++ -std=c++17 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
            fi
          done < <(find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No C++ sources -> skipping compile"
          fi

      - name: Compile all C++ translation units (no linking) (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          New-Item -ItemType Directory -Force -Path build_cpp/obj | Out-Null
          $files = Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No C++ sources -> skipping compile"; exit 0 }
          foreach ($f in $files) {
            $safe = ($f.FullName -replace '^[A-Za-z]:\\', '' -replace '[\\/]', '_')
            $out = "build_cpp/obj/$safe.obj"
            Write-Host "CXX $($f.FullName)"
            & clang++ -std=c++17 -Wall -Wextra -Werror -O2 -c $f.FullName -o $out
          }

      - name: C++ skipped (no C++ sources)
        if: steps.cppcheck.outputs.has_cpp != 'true'
        run: echo "No C++ files found -> skipping C++ job"

  # =========================
  # C++ DYNAMIC (Linux only)
  # =========================
  quality-cpp-dynamic:
    name: "C++ (dynamic: ASan/UBSan + Valgrind) on Linux"
    runs-on: ubuntu-24.04
    timeout-minutes: 12
    needs: [guard-crlf]
    steps:
      - uses: actions/checkout@v4

      - name: Detect C++ files
        id: cppcheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*" | grep -q .; then
            echo "has_cpp=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_cpp=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install C++ tools (Linux)
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang++ valgrind

      - name: Link & run with sanitizers + valgrind (only if exactly one main) [C++]
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          MAIN_FILES="$(grep -Rsn --include="*.cpp" --include="*.cc" --include="*.cxx" -E '^\s*(int|auto)\s+main\s*\(' . | cut -d: -f1 | sort -u || true)"
          if [ -z "$MAIN_FILES" ]; then
            echo "No main() found -> skipping dynamic analysis"
            exit 0
          fi
          if [ "$(echo "$MAIN_FILES" | wc -l | tr -d ' ')" -ne 1 ]; then
            echo "Multiple main() found -> skipping link/run"
            echo "$MAIN_FILES"
            exit 0
          fi

          mkdir -p build_cpp
          CPP_FILES="$(find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*")"

          echo "Build + run (sanitizers):"
          clang++ -std=c++17 -Wall -Wextra -Werror -O1 -g \
            -fsanitize=address,undefined -fno-omit-frame-pointer \
            $CPP_FILES -o build_cpp/app_asan
          ./build_cpp/app_asan

          echo "Build + run (valgrind on non-sanitized binary):"
          clang++ -std=c++17 -Wall -Wextra -Werror -O1 -g \
            $CPP_FILES -o build_cpp/app_vg
          valgrind --error-exitcode=1 --leak-check=full ./build_cpp/app_vg

      - name: C++ dynamic skipped (no C++ sources)
        if: steps.cppcheck.outputs.has_cpp != 'true'
        run: echo "No C++ files found -> skipping C++ dynamic job"

  # =========================
  # PYTHON (all OS)
  # =========================
  quality-python:
    name: "Python (format + static + compile + tests/run) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 10
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect Python files
        id: pycheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.py" ! -path "./.git/*" | grep -q .; then
            echo "has_py=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_py=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-python@v5
        if: steps.pycheck.outputs.has_py == 'true'
        with:
          python-version: "3.11"

      - name: Install Python quality tools (only if Python exists)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install ruff mypy pytest

      - name: Python format check (ruff format)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff format --check .

      - name: Python lint (ruff)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff check .

      - name: Python type-check (mypy, best-effort)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m mypy . || true

      - name: Python syntax check (compileall)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m compileall -q .

      - name: Python tests (pytest if present, else run single script if unique)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ -d "tests" ] || find . -maxdepth 3 -type f -name "test_*.py" | grep -q .; then
            python -m pytest -q
            exit 0
          fi

          count=0
          last=""
          while IFS= read -r f; do
            count=$((count+1))
            last="$f"
          done < <(find . -type f -name "*.py" ! -path "./.git/*" | sort)

          if [ "$count" -eq 1 ]; then
            echo "No tests found. Running single script: $last"
            python -u "$last"
          else
            echo "No tests and multiple .py files -> skipping run"
          fi

      - name: Python skipped (no .py)
        if: steps.pycheck.outputs.has_py != 'true'
        run: echo "No .py files found -> skipping"

  # =========================
  # JAVA (all OS)
  # =========================
  quality-java:
    name: "Java (style + static + compile + tests/run) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect Java files
        id: javacheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.java" ! -path "./.git/*" | grep -q .; then
            echo "has_java=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_java=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-java@v4
        if: steps.javacheck.outputs.has_java == 'true'
        with:
          distribution: temurin
          java-version: "17"

      - name: Install Java static tools (Linux)
        if: steps.javacheck.outputs.has_java == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends checkstyle spotbugs

      - name: Install Java static tools (macOS)
        if: steps.javacheck.outputs.has_java == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install checkstyle spotbugs

      - name: Install Java static tools (Windows)
        if: steps.javacheck.outputs.has_java == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y checkstyle spotbugs

      - name: Java style check (Checkstyle - basic)
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cat > checkstyle.xml <<'XML'
          <!DOCTYPE module PUBLIC
            "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
            "https://checkstyle.org/dtds/configuration_1_3.dtd">
          <module name="Checker">
            <module name="TreeWalker">
              <module name="NeedBraces"/>
              <module name="UnusedImports"/>
              <module name="AvoidStarImport"/>
              <module name="LineLength">
                <property name="max" value="120"/>
              </module>
            </module>
          </module>
          XML

          found=0
          files=""
          while IFS= read -r f; do
            found=1
            files="$files \"$f\""
          done < <(find . -type f -name "*.java" ! -path "./.git/*")

          if [ "$found" -eq 0 ]; then
            echo "No .java files -> skipping checkstyle"
            exit 0
          fi

          # shellcheck disable=SC2086
          eval checkstyle -c checkstyle.xml $files

      - name: Compile all Java files
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          found=0
          files=""
          while IFS= read -r f; do
            found=1
            files="$files \"$f\""
          done < <(find . -type f -name "*.java" ! -path "./.git/*")

          if [ "$found" -eq 0 ]; then
            echo "No .java files -> skipping javac"
            exit 0
          fi

          # shellcheck disable=SC2086
          eval javac -d out $files

      - name: Static analysis (SpotBugs) (best-effort)
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d out ]; then
            echo "No compiled classes -> skipping spotbugs"
            exit 0
          fi
          spotbugs -textui -effort:max -high -classpath out -auxclasspath out out || true

      - name: Run tests if Maven/Gradle, else run if exactly one main
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail

          if [ -f "pom.xml" ]; then
            echo "pom.xml found -> running mvn test"
            if [ "${RUNNER_OS}" = "Windows" ]; then
              choco install -y maven
            elif [ "${RUNNER_OS}" = "macOS" ]; then
              brew install maven
            else
              sudo apt-get update && sudo apt-get install -y maven
            fi
            mvn -q test
            exit 0
          fi

          if [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            echo "gradle build found -> running gradle test"
            if [ "${RUNNER_OS}" = "Windows" ]; then
              choco install -y gradle
            elif [ "${RUNNER_OS}" = "macOS" ]; then
              brew install gradle
            else
              sudo apt-get update && sudo apt-get install -y gradle
            fi
            gradle test
            exit 0
          fi

          MAIN_SRCS="$(grep -Rsl --include="*.java" "public static void main" . | sort || true)"
          if [ -z "$MAIN_SRCS" ]; then
            echo "No main() found -> skipping run"
            exit 0
          fi
          if [ "$(echo "$MAIN_SRCS" | wc -l | tr -d ' ')" -ne 1 ]; then
            echo "Multiple main() found -> skipping run"
            echo "$MAIN_SRCS"
            exit 0
          fi

          MAIN_SRC="$(echo "$MAIN_SRCS" | head -n 1)"
          PKG="$(grep -E "^\s*package\s+" "$MAIN_SRC" | head -n 1 | sed -E 's/^\s*package\s+([a-zA-Z0-9_.]+)\s*;\s*$/\1/' || true)"
          CLS="$(grep -E "class\s+[A-Za-z_][A-Za-z0-9_]*" "$MAIN_SRC" | head -n 1 | sed -E 's/.*class\s+([A-Za-z_][A-Za-z0-9_]*).*/\1/')"

          if [ -z "$CLS" ]; then
            echo "Could not detect class name -> skipping run"
            exit 0
          fi

          if [ -n "$PKG" ]; then MAIN="$PKG.$CLS"; else MAIN="$CLS"; fi
          echo "Running Java main: $MAIN"
          java -cp out "$MAIN"

      - name: Java skipped (no .java)
        if: steps.javacheck.outputs.has_java != 'true'
        run: echo "No .java files found -> skipping"
