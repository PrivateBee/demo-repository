name: "CI Quality (LLVM style + Static/Dynamic) - C/C++/Python/Java (Linux/Windows/macOS)"

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  # ==========================================================
  # COMMON: CRLF guard (runs on Linux; detects Windows CRLF)
  # ==========================================================
  guard-crlf:
    name: "Guard (no CRLF in sources)"
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - uses: actions/checkout@v4

      - name: Fail if CRLF detected in source files
        shell: bash
        run: |
          set -euo pipefail
          if git grep -Il $'\r' -- \
            '*.c' '*.h' '*.cpp' '*.hpp' '*.hxx' '*.cc' '*.cxx' \
            '*.py' '*.java' '*.sh' '*.yml' '*.yaml' '*.md' ; then
            echo "::error::CRLF detected in files above. Fix by converting to LF and/or using .gitattributes."
            exit 1
          fi
          echo "OK: no CRLF found in targeted files."

  # =========================
  # C (force LLVM format + static + compile) on all OS
  # =========================
  quality-c:
    name: "C (force LLVM format + static + compile) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect C files
        id: ccheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.c" ! -path "./.git/*" | grep -q .; then
            echo "has_c=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_c=false" >> "$GITHUB_OUTPUT"
          fi

      # -------- Install tools per OS --------
      - name: Install C tools (Linux)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang-format clang-tidy cppcheck

      - name: Install C tools (macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C tools (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      # -------------------------
      # 0) FORCE LLVM FORMAT (clang-format -style=LLVM -i ...)
      # -------------------------
      - name: Force LLVM format (C) - clang-format -i (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*" -print0 \
            | xargs -0 -I{} clang-format -style=LLVM -i "{}"

      - name: Force LLVM format (C) - clang-format -i (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Get-ChildItem -Recurse -File -Include *.c,*.h |
            Where-Object { $_.FullName -notmatch "\\.git\\" } |
            ForEach-Object { & clang-format -style=LLVM -i $_.FullName }

      # -------------------------
      # 1) CHECK LLVM STYLE
      #    - Linux/macOS: diff
      #    - Windows: write formatted to temp file, normalize both files, compare bytes
      # -------------------------
      - name: Check LLVM style (clang-format) [C] (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          found=0
          while IFS= read -r f; do
            found=1
            clang-format -style=LLVM "$f" | diff -u "$f" - >/dev/null || {
              echo "::error file=$f::clang-format LLVM mismatch"
              exit 1
            }
          done < <(find . -type f \( -name "*.c" -o -name "*.h" \) ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No C files -> skipping format check"
          fi

      - name: Check LLVM style (clang-format) [C] (Windows - robust)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"

          function Normalize-File([string]$path) {
            $bytes = [System.IO.File]::ReadAllBytes($path)

            # Remove UTF-8 BOM if present
            if ($bytes.Length -ge 3 -and $bytes[0] -eq 0xEF -and $bytes[1] -eq 0xBB -and $bytes[2] -eq 0xBF) {
              $bytes = $bytes[3..($bytes.Length-1)]
            }

            $text = [System.Text.Encoding]::UTF8.GetString($bytes)
            $text = $text -replace "`r`n", "`n"
            $text = $text -replace "`r", "`n"

            # Ensure newline at EOF to stabilize diffs
            if ($text.Length -gt 0 -and -not $text.EndsWith("`n")) {
              $text += "`n"
            }

            [System.IO.File]::WriteAllText($path, $text, (New-Object System.Text.UTF8Encoding($false)))
          }

          $files = Get-ChildItem -Recurse -File -Include *.c,*.h |
            Where-Object { $_.FullName -notmatch "\\.git\\" }

          if ($files.Count -eq 0) { Write-Host "No C files -> skipping"; exit 0 }

          foreach ($f in $files) {
            $tmp = Join-Path $env:RUNNER_TEMP ("cf_" + [System.Guid]::NewGuid().ToString() + ".tmp")

            $formatted = & clang-format -style=LLVM $f.FullName
            [System.IO.File]::WriteAllText($tmp, $formatted, (New-Object System.Text.UTF8Encoding($false)))

            Normalize-File $f.FullName
            Normalize-File $tmp

            $a = [System.IO.File]::ReadAllBytes($f.FullName)
            $b = [System.IO.File]::ReadAllBytes($tmp)

            if ($a.Length -ne $b.Length) {
              Write-Error "clang-format LLVM mismatch: $($f.FullName). Fix with: clang-format -style=LLVM -i `"$($f.FullName)`""
              exit 1
            }

            for ($i=0; $i -lt $a.Length; $i++) {
              if ($a[$i] -ne $b[$i]) {
                Write-Error "clang-format LLVM mismatch: $($f.FullName). Fix with: clang-format -style=LLVM -i `"$($f.FullName)`""
                exit 1
              }
            }

            Remove-Item -Force $tmp
          }

      # -------------------------
      # 2) STATIC ANALYSIS
      # -------------------------
      - name: Static analysis (cppcheck) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: Static analysis (clang-tidy if compile_commands.json exists) [C]
        if: steps.ccheck.outputs.has_c == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f compile_commands.json ]; then
            echo "No compile_commands.json -> skipping clang-tidy"
            exit 0
          fi
          found=0
          while IFS= read -r f; do
            found=1
            clang-tidy -p . -checks="-*,clang-analyzer-*" "$f"
          done < <(find . -type f -name "*.c" ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No .c files -> skipping clang-tidy"
          fi

      # -------------------------
      # 3) BUILD (compile everything, no linking)
      # -------------------------
      - name: Compile all C translation units (no linking) (Linux/macOS)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build_c/obj
          found=0
          while IFS= read -r f; do
            found=1
            out="build_c/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            echo "CC  $f"
            clang -std=c11 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
          done < <(find . -type f -name "*.c" ! -path "./.git/*")
          if [ "$found" -eq 0 ]; then
            echo "No .c files -> skipping compile"
          fi

      - name: Compile all C translation units (no linking) (Windows)
        if: steps.ccheck.outputs.has_c == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          New-Item -ItemType Directory -Force -Path build_c/obj | Out-Null
          $files = Get-ChildItem -Recurse -File -Filter *.c | Where-Object { $_.FullName -notmatch "\\.git\\" }
          if ($files.Count -eq 0) { Write-Host "No .c files -> skipping compile"; exit 0 }
          foreach ($f in $files) {
            $safe = ($f.FullName -replace '^[A-Za-z]:\\', '' -replace '[\\/]', '_')
            $out = "build_c/obj/$safe.obj"
            Write-Host "CC  $($f.FullName)"
            & clang -std=c11 -Wall -Wextra -Werror -O2 -c $f.FullName -o $out
          }

      - name: C skipped (no .c)
        if: steps.ccheck.outputs.has_c != 'true'
        run: echo "No .c files found -> skipping C job"

  # =========================
  # C++ (force LLVM format + static + compile) on all OS
  # =========================
  quality-cpp:
    name: "C++ (force LLVM format + static + compile) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect C++ files
        id: cppcheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f \( -name "*.cpp" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.cc" -o -name "*.cxx" \) ! -path "./.git/*" | grep -q .; then
            echo "has_cpp=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_cpp=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Install C++ tools (Linux)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Linux'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends clang clang++ clang-format clang-tidy cppcheck

      - name: Install C++ tools (macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          brew update
          brew install llvm cppcheck
          echo "$(brew --prefix llvm)/bin" >> "$GITHUB_PATH"

      - name: Install C++ tools (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          choco install -y llvm cppcheck
          $llvmBin = "C:\Program Files\LLVM\bin"
          echo $llvmBin | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append

      - name: Force LLVM format (C++) - clang-format -i (Linux/macOS)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os != 'Windows'
        shell: bash
        run: |
          set -euo pipefail
          find . -type f \( -name "*.cpp" -o -name "*.cc" -o -name "*.cxx" -o -name "*.hpp" -o -name "*.hxx" -o -name "*.h" \) ! -path "./.git/*" -print0 \
            | xargs -0 -I{} clang-format -style=LLVM -i "{}"

      - name: Force LLVM format (C++) - clang-format -i (Windows)
        if: steps.cppcheck.outputs.has_cpp == 'true' && runner.os == 'Windows'
        shell: pwsh
        run: |
          $ErrorActionPreference = "Stop"
          Get-ChildItem -Recurse -File -Include *.cpp,*.cc,*.cxx,*.hpp,*.hxx,*.h |
            Where-Object { $_.FullName -notmatch "\\.git\\" } |
            ForEach-Object { & clang-format -style=LLVM -i $_.FullName }

      - name: Static analysis (cppcheck) [C++]
        if: steps.cppcheck.outputs.has_cpp == 'true'
        shell: bash
        run: |
          set -euo pipefail
          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: C++ skipped (no C++ sources)
        if: steps.cppcheck.outputs.has_cpp != 'true'
        run: echo "No C++ files found -> skipping C++ job"

  # =========================
  # PYTHON (all OS)
  # =========================
  quality-python:
    name: "Python (format + static + compile + tests/run) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 10
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect Python files
        id: pycheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.py" ! -path "./.git/*" | grep -q .; then
            echo "has_py=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_py=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-python@v5
        if: steps.pycheck.outputs.has_py == 'true'
        with:
          python-version: "3.11"

      - name: Install Python quality tools (only if Python exists)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          python -m pip install ruff mypy pytest

      - name: Python format check (ruff format)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff format --check .

      - name: Python lint (ruff)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m ruff check .

      - name: Python skipped (no .py)
        if: steps.pycheck.outputs.has_py != 'true'
        run: echo "No .py files found -> skipping"

  # =========================
  # JAVA (all OS)
  # =========================
  quality-java:
    name: "Java (style + static + compile) on ${{ matrix.os }}"
    runs-on: ${{ matrix.os }}
    timeout-minutes: 12
    needs: [guard-crlf]
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-24.04, windows-2022, macos-14]

    steps:
      - uses: actions/checkout@v4

      - name: Detect Java files
        id: javacheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.java" ! -path "./.git/*" | grep -q .; then
            echo "has_java=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_java=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-java@v4
        if: steps.javacheck.outputs.has_java == 'true'
        with:
          distribution: temurin
          java-version: "17"

      - name: Java skipped (no .java)
        if: steps.javacheck.outputs.has_java != 'true'
        run: echo "No .java files found -> skipping"
