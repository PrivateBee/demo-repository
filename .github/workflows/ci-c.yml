name: CI Quality (GNU style + Static/Dynamic) - C/C++/Python/Java

on:
  pull_request:
    branches: ["main"]
  push:
    branches: ["main"]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  quality-c-cpp:
    name: C/C++ (GNU format + static + dynamic)
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4

      - name: Install C/C++ tools
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            clang clang++ \
            clang-format clang-tidy \
            cppcheck valgrind

      # -------------------------
      # 1) GNU STYLE CHECK
      # -------------------------
      - name: Check GNU style (clang-format)
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t FMT_FILES < <(
            find . -type f \( -name "*.c" -o -name "*.h" -o -name "*.hpp" -o -name "*.cpp" \) \
              ! -path "./.git/*"
          )
          if [ "${#FMT_FILES[@]}" -eq 0 ]; then
            echo "No C/C++ files -> skipping format check"
            exit 0
          fi

          for f in "${FMT_FILES[@]}"; do
            clang-format -style=GNU "$f" | diff -u "$f" - >/dev/null || {
              echo "::error file=$f::clang-format GNU mismatch. Fix with: clang-format -style=GNU -i $f"
              exit 1
            }
          done

      # -------------------------
      # 2) STATIC ANALYSIS
      # -------------------------
      - name: Static analysis (cppcheck)
        shell: bash
        run: |
          set -euo pipefail
          mapfile -t SRC_FILES < <(
            find . -type f \( -name "*.c" -o -name "*.cpp" -o -name "*.h" -o -name "*.hpp" \) \
              ! -path "./.git/*"
          )
          if [ "${#SRC_FILES[@]}" -eq 0 ]; then
            echo "No C/C++ files -> skipping cppcheck"
            exit 0
          fi

          cppcheck --enable=all --inconclusive \
            --inline-suppr --error-exitcode=1 \
            --suppress=missingIncludeSystem \
            .

      - name: Static analysis (clang-tidy if compile_commands.json exists)
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -f compile_commands.json ]; then
            echo "No compile_commands.json -> skipping clang-tidy (cppcheck already done)"
            exit 0
          fi

          mapfile -t TIDY_FILES < <(find . -type f -name "*.cpp" ! -path "./.git/*")
          if [ "${#TIDY_FILES[@]}" -eq 0 ]; then
            echo "No .cpp files -> skipping clang-tidy"
            exit 0
          fi

          clang-tidy -p . \
            -checks="-*,clang-analyzer-*,bugprone-*,performance-*,readability-*" \
            "${TIDY_FILES[@]}"

      # -------------------------
      # 3) BUILD (compile everything, no linking)
      # -------------------------
      - name: Compile all C/C++ translation units (no linking)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p build/obj

          mapfile -t C_FILES < <(find . -type f -name "*.c" ! -path "./.git/*")
          mapfile -t CPP_FILES < <(find . -type f -name "*.cpp" ! -path "./.git/*")

          if [ "${#C_FILES[@]}" -eq 0 ] && [ "${#CPP_FILES[@]}" -eq 0 ]; then
            echo "No C/C++ sources -> skipping"
            exit 0
          fi

          for f in "${C_FILES[@]}"; do
            out="build/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            echo "CC  $f"
            gcc -std=c11 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
          done

          for f in "${CPP_FILES[@]}"; do
            out="build/obj/$(echo "$f" | sed 's|^\./||; s|/|_|g').o"
            echo "CXX $f"
            g++ -std=c++17 -Wall -Wextra -Werror -O2 -c "$f" -o "$out"
          done

      # -------------------------
      # 4) DYNAMIC ANALYSIS (only if exactly one main)
      # -------------------------
      - name: Link & run with sanitizers + valgrind (only if exactly one main)
        shell: bash
        run: |
          set -euo pipefail

          mapfile -t MAIN_FILES < <(
            grep -Rsn --include="*.c" --include="*.cpp" -E '^\s*(int|auto)\s+main\s*\(' . \
              | cut -d: -f1 | sort -u
          )

          if [ "${#MAIN_FILES[@]}" -eq 0 ]; then
            echo "No main() found -> skipping dynamic analysis"
            exit 0
          fi

          if [ "${#MAIN_FILES[@]}" -ne 1 ]; then
            echo "Found multiple main() files -> skipping link/run"
            printf '%s\n' "${MAIN_FILES[@]}"
            exit 0
          fi

          mkdir -p build
          mapfile -t C_FILES < <(find . -type f -name "*.c" ! -path "./.git/*")
          mapfile -t CPP_FILES < <(find . -type f -name "*.cpp" ! -path "./.git/*")

          if [ "${#CPP_FILES[@]}" -gt 0 ]; then
            echo "Linking with clang++ + ASan/UBSan"
            clang++ -std=c++17 -Wall -Wextra -Werror -O1 -g \
              -fsanitize=address,undefined -fno-omit-frame-pointer \
              "${CPP_FILES[@]}" "${C_FILES[@]}" -o build/app_san
          else
            echo "Linking with clang + ASan/UBSan"
            clang -std=c11 -Wall -Wextra -Werror -O1 -g \
              -fsanitize=address,undefined -fno-omit-frame-pointer \
              "${C_FILES[@]}" -o build/app_san
          fi

          echo "Run (sanitizers):"
          ./build/app_san

          echo "Run (valgrind):"
          valgrind --error-exitcode=1 --leak-check=full ./build/app_san

  quality-python:
    name: Python (format + static + compile + tests/run)
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - uses: actions/checkout@v4

      - name: Detect Python files
        id: pycheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.py" ! -path "./.git/*" | grep -q .; then
            echo "has_py=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_py=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-python@v5
        if: steps.pycheck.outputs.has_py == 'true'
        with:
          python-version: "3.11"

      - name: Install Python quality tools (ruff, mypy, pytest)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m pip install --upgrade pip
          pip install ruff mypy pytest

      # --- Format/style: use ruff format (fast) ---
      - name: Python format check (ruff format)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          ruff format --check .

      # --- Static: lint ---
      - name: Python lint (ruff)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          ruff check .

      # --- Static: typing (best-effort) ---
      - name: Python type-check (mypy, best-effort)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Sur un repo sans annotations, mypy peut Ãªtre bruyant.
          # Tu peux le durcir plus tard avec une config mypy.ini
          mypy . || true

      # --- "Compile" all python to bytecode (syntax) ---
      - name: Python syntax check (compileall)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          python -m compileall -q .

      # --- Dynamic: tests if present, else run 1 entrypoint if unique ---
      - name: Python tests (pytest if present, else run single script if unique)
        if: steps.pycheck.outputs.has_py == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ -d "tests" ] || find . -maxdepth 3 -type f -name "test_*.py" | grep -q .; then
            pytest -q
            exit 0
          fi

          # Run only if exactly one python file (simple repos)
          mapfile -t PY_FILES < <(find . -type f -name "*.py" ! -path "./.git/*" | sort)
          if [ "${#PY_FILES[@]}" -eq 1 ]; then
            echo "No tests found. Running single script: ${PY_FILES[0]}"
            python -u "${PY_FILES[0]}"
          else
            echo "No tests and multiple .py files -> skipping run"
          fi

      - name: Python skipped (no .py)
        if: steps.pycheck.outputs.has_py != 'true'
        run: echo "No .py files found -> skipping"

  quality-java:
    name: Java (format-like + static + compile + tests/run)
    runs-on: ubuntu-latest
    timeout-minutes: 12
    steps:
      - uses: actions/checkout@v4

      - name: Detect Java files
        id: javacheck
        shell: bash
        run: |
          set -euo pipefail
          if find . -type f -name "*.java" ! -path "./.git/*" | grep -q .; then
            echo "has_java=true" >> "$GITHUB_OUTPUT"
          else
            echo "has_java=false" >> "$GITHUB_OUTPUT"
          fi

      - uses: actions/setup-java@v4
        if: steps.javacheck.outputs.has_java == 'true'
        with:
          distribution: temurin
          java-version: "17"

      - name: Install Java static tools (checkstyle, spotbugs)
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends checkstyle spotbugs

      # NOTE: checkstyle needs a config. If you don't have one, we generate a basic one on the fly.
      - name: Java style check (Checkstyle - basic)
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          # Minimal checkstyle config (tu peux le remplacer par ton checkstyle.xml)
          cat > checkstyle.xml <<'XML'
          <!DOCTYPE module PUBLIC
            "-//Checkstyle//DTD Checkstyle Configuration 1.3//EN"
            "https://checkstyle.org/dtds/configuration_1_3.dtd">
          <module name="Checker">
            <module name="TreeWalker">
              <module name="NeedBraces"/>
              <module name="UnusedImports"/>
              <module name="AvoidStarImport"/>
              <module name="LineLength">
                <property name="max" value="120"/>
              </module>
            </module>
          </module>
          XML

          mapfile -t JAVA_FILES < <(find . -type f -name "*.java" ! -path "./.git/*")
          checkstyle -c checkstyle.xml "${JAVA_FILES[@]}"

      - name: Compile all Java files
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p out
          mapfile -t JAVA_FILES < <(find . -type f -name "*.java" ! -path "./.git/*")
          javac -d out "${JAVA_FILES[@]}"

      # SpotBugs without a build tool is limited; we run it on compiled classes.
      - name: Static analysis (SpotBugs)
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail
          if [ ! -d out ]; then
            echo "No compiled classes -> skipping spotbugs"
            exit 0
          fi
          # -exitcode makes CI fail on bugs
          spotbugs -textui -effort:max -high -exitcode -classpath out -auxclasspath out out || true

      - name: Run tests if present (JUnit) else run if exactly one main
        if: steps.javacheck.outputs.has_java == 'true'
        shell: bash
        run: |
          set -euo pipefail

          # If repo uses Maven/Gradle, better to use them:
          if [ -f "pom.xml" ]; then
            echo "pom.xml found -> running mvn test"
            sudo apt-get update && sudo apt-get install -y maven
            mvn -q test
            exit 0
          fi
          if [ -f "build.gradle" ] || [ -f "build.gradle.kts" ]; then
            echo "gradle build found -> running gradle test"
            sudo apt-get update && sudo apt-get install -y gradle
            gradle test
            exit 0
          fi

          # No build tool: run only if exactly one main
          mapfile -t MAIN_SRCS < <(grep -Rsl --include="*.java" "public static void main" . | sort)
          if [ "${#MAIN_SRCS[@]}" -eq 0 ]; then
            echo "No main() found -> skipping run"
            exit 0
          fi
          if [ "${#MAIN_SRCS[@]}" -ne 1 ]; then
            echo "Multiple main() found -> skipping run"
            printf '%s\n' "${MAIN_SRCS[@]}"
            exit 0
          fi

          MAIN_SRC="${MAIN_SRCS[0]}"
          PKG=$(grep -E "^\s*package\s+" "$MAIN_SRC" | head -n 1 | sed -E 's/^\s*package\s+([a-zA-Z0-9_.]+)\s*;\s*$/\1/' || true)
          CLS=$(grep -E "class\s+[A-Za-z_][A-Za-z0-9_]*" "$MAIN_SRC" | head -n 1 | sed -E 's/.*class\s+([A-Za-z_][A-Za-z0-9_]*).*/\1/')

          if [ -z "$CLS" ]; then
            echo "Could not detect class name -> skipping run"
            exit 0
          fi

          if [ -n "$PKG" ]; then MAIN="$PKG.$CLS"; else MAIN="$CLS"; fi
          echo "Running Java main: $MAIN"
          java -cp out "$MAIN"

      - name: Java skipped (no .java)
        if: steps.javacheck.outputs.has_java != 'true'
        run: echo "No .java files found -> skipping"
